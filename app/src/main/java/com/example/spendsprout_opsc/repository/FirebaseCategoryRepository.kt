package com.example.spendsprout_opsc.repository

import android.util.Log
import com.example.spendsprout_opsc.model.Category
import com.example.spendsprout_opsc.model.Subcategory
import com.google.firebase.database.DataSnapshot
import com.google.firebase.database.DatabaseError
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.ValueEventListener
import com.google.firebase.database.ktx.getValue
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await
import javax.inject.Inject

class FirebaseCategoryRepository @Inject constructor(
    private val database: FirebaseDatabase
) : CategoryRepository {

    private val tag = "FirebaseCategoryRepo"
    private val categoriesRef = database.getReference("categories")

    override fun getAllCategories(): Flow<List<Category>> = callbackFlow {
        val listener = object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val categories = snapshot.children.mapNotNull { catSnapshot ->
                    // Manually deserialize and set the ID from the snapshot key
                    val category = catSnapshot.getValue(Category::class.java)
                    category?.copy(categoryId = catSnapshot.key ?: "")
                }
                trySend(categories)
                Log.d(tag, "Loaded ${categories.size} categories.")
            }

            override fun onCancelled(error: DatabaseError) {
                Log.e(tag, "getAllCategories failed", error.toException())
                close(error.toException())
            }
        }
        categoriesRef.addValueEventListener(listener)
        awaitClose { categoriesRef.removeEventListener(listener) }
    }

    override suspend fun getCategory(categoryId: String): Category? {
        return try {
            val snapshot = categoriesRef.child(categoryId).get().await()
            snapshot.getValue<Category>()?.copy(categoryId = snapshot.key ?: "")
        } catch (e: Exception) {
            Log.e(tag, "getCategory failed for id: $categoryId", e)
            null
        }
    }

    override suspend fun addCategory(category: Category) {
        val categoryId = categoriesRef.push().key ?: throw IllegalStateException("Could not generate category ID")
        // Don't trust the incoming categoryId, always use the one generated by Firebase
        categoriesRef.child(categoryId).setValue(category.copy(categoryId = categoryId)).await()
        Log.d(tag, "addCategory successful for id: $categoryId")
    }

    override suspend fun updateCategory(category: Category) {
        if (category.categoryId.isEmpty()) throw IllegalArgumentException("Category ID cannot be empty")
        categoriesRef.child(category.categoryId).setValue(category).await()
        Log.d(tag, "updateCategory successful for id: ${category.categoryId}")
    }

    override suspend fun deleteCategory(categoryId: String) {
        if (categoryId.isEmpty()) throw IllegalArgumentException("Category ID cannot be empty")
        categoriesRef.child(categoryId).removeValue().await()
        Log.d(tag, "deleteCategory successful for id: $categoryId")
    }

    // Subcategory Methods
    override fun getAllSubcategories(): Flow<List<Subcategory>> = callbackFlow {
        val listener = object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val allSubcategories = snapshot.children.flatMap { catSnapshot ->
                    val subcategoriesMap = catSnapshot.child("subcategories").children
                    subcategoriesMap.mapNotNull { subSnapshot ->
                        val sub = subSnapshot.getValue(Subcategory::class.java)
                        sub?.copy(subcategoryId = subSnapshot.key ?: "")
                    }
                }
                trySend(allSubcategories)
                Log.d(tag, "Loaded ${allSubcategories.size} subcategories in total.")
            }

            override fun onCancelled(error: DatabaseError) {
                Log.e(tag, "getAllSubcategories failed", error.toException())
                close(error.toException())
            }
        }
        categoriesRef.addValueEventListener(listener)
        awaitClose { categoriesRef.removeEventListener(listener) }
    }


    override fun getSubcategoriesForCategory(categoryId: String): Flow<List<Subcategory>> = callbackFlow {
        val subcategoriesRef = categoriesRef.child(categoryId).child("subcategories")
        val listener = object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                val subcategories = snapshot.children.mapNotNull { subSnapshot ->
                    subSnapshot.getValue<Subcategory>()?.copy(subcategoryId = subSnapshot.key ?: "")
                }
                trySend(subcategories)
                Log.d(tag, "Loaded ${subcategories.size} subcategories for category $categoryId.")
            }
            override fun onCancelled(error: DatabaseError) {
                Log.e(tag, "getSubcategoriesForCategory failed for category $categoryId", error.toException())
                close(error.toException())
            }
        }
        subcategoriesRef.addValueEventListener(listener)
        awaitClose { subcategoriesRef.removeEventListener(listener) }
    }

    override suspend fun getSubcategory(categoryId: String, subcategoryId: String): Subcategory? {
         return try {
            val snapshot = categoriesRef.child(categoryId).child("subcategories").child(subcategoryId).get().await()
            snapshot.getValue<Subcategory>()?.copy(subcategoryId = snapshot.key ?: "")
        } catch (e: Exception) {
            Log.e(tag, "getSubcategory failed for id: $subcategoryId", e)
            null
        }
    }

    override suspend fun addSubcategory(categoryId: String, subcategory: Subcategory) {
        val subcategoriesRef = categoriesRef.child(categoryId).child("subcategories")
        val subcategoryId = subcategoriesRef.push().key ?: throw IllegalStateException("Could not generate subcategory ID")
        subcategoriesRef.child(subcategoryId).setValue(subcategory.copy(subcategoryId = subcategoryId)).await()
        Log.d(tag, "addSubcategory successful for id: $subcategoryId")
    }

    override suspend fun updateSubcategory(categoryId: String, subcategory: Subcategory) {
        if (subcategory.subcategoryId.isEmpty()) throw IllegalArgumentException("Subcategory ID cannot be empty")
        categoriesRef.child(categoryId).child("subcategories").child(subcategory.subcategoryId).setValue(subcategory).await()
        Log.d(tag, "updateSubcategory successful for id: ${subcategory.subcategoryId}")
    }

    override suspend fun deleteSubcategory(categoryId: String, subcategoryId: String) {
        if (subcategoryId.isEmpty()) throw IllegalArgumentException("Subcategory ID cannot be empty")
        categoriesRef.child(categoryId).child("subcategories").child(subcategoryId).removeValue().await()
        Log.d(tag, "deleteSubcategory successful for id: $subcategoryId")
    }

    override suspend fun addDefaultCategoriesIfEmpty() {
        val listener = object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                if (!snapshot.exists()) {
                    Log.d(tag, "No categories found. Adding default categories.")
                    // In a real app, you'd define these defaults properly
                    val defaultCategories = listOf(
                        Category(name = "Food", subcategories = mapOf("groceries" to Subcategory(name = "Groceries"), "restaurants" to Subcategory(name = "Restaurants"))),
                        Category(name = "Transport", subcategories = mapOf("fuel" to Subcategory(name = "Fuel"), "public" to Subcategory(name = "Public Transport"))),
                        Category(name = "Entertainment", subcategories = mapOf("movies" to Subcategory(name = "Movies"), "games" to Subcategory(name = "Games")))
                    )
                    defaultCategories.forEach { category ->
                        val categoryId = categoriesRef.push().key!!
                        categoriesRef.child(categoryId).setValue(category.copy(categoryId = categoryId))
                    }
                }
                categoriesRef.removeEventListener(this) // important to remove a single value event listener
            }

            override fun onCancelled(error: DatabaseError) {
                Log.e(tag, "Failed to check for existing categories.", error.toException())
                 categoriesRef.removeEventListener(this)
            }
        }
        categoriesRef.addListenerForSingleValueEvent(listener)
    }
}
